# Story 4.3: Create a New Repair Job

## Status
DONE

## Story
**As a** User,
**I want** to create a new repair job by selecting a customer, describing the job, adding parts used, and setting a total price,
**so that** I can manage my repair services.

## Acceptance Criteria
1. The user can start "Create New Repair Job" from the "Repairs" page.
2. The user must select a "Customer".
3. The user must enter a "Job Title" and description.
4. The user can search for and add multiple "Products (spare parts)" from stock to the repair job.
5. For each spare part, the system records the `cost_at_time` from the product's current `average_cost`.
6. The user must enter the `total_cost` (the total repair price agreed upon with the customer).
7. When the repair job is saved, the `quantity` of each spare part used is deducted from the stock.
8. The new repair job appears in the repair job history list.

## Tasks / Subtasks
- [x] Create repair tRPC router with repair creation procedure (AC: 1-8)
  - [x] Create new `src/server/api/routers/repair.ts` file
  - [x] Implement Zod input validation for repair creation parameters (customer, description, parts, total cost)
  - [x] Create repair creation procedure with Prisma transaction for data consistency
  - [x] Implement parts cost calculation from product average costs (AC: 5)
  - [x] Implement automatic stock deduction for all used parts (AC: 7)
  - [x] Implement repair cost calculations (total cost, parts cost, labor cost)
  - [x] Add proper error handling for insufficient stock, invalid customers, etc.
  - [x] Add repair to appRouter in `src/server/api/root.ts`
- [x] Create repairs page with repair job history list (AC: 1, 8)
  - [x] Create new page at `src/app/(main)/repairs/page.tsx` following existing patterns
  - [x] Implement repairs history table component showing customer, description, date, total cost
  - [x] Add "Create New Repair Job" button to start repair creation (AC: 1)
  - [x] Implement loading states and error handling for data fetching
  - [x] Add navigation and consistent styling with existing pages
  - [x] Ensure responsive design following established patterns
- [x] Create repair job creation form component (AC: 2-7)
  - [x] Create repair creation form with customer selection dropdown (AC: 2)
  - [x] Add job description/title input field (AC: 3)
  - [x] Implement parts selection interface with product search and quantity input (AC: 4)
  - [x] Add parts table showing selected parts with costs from average cost (AC: 5)
  - [x] Add total cost input field for repair price (AC: 6)
  - [x] Implement automatic parts cost and labor cost calculations
  - [x] Add form validation and error handling
  - [x] Implement save functionality with stock deduction confirmation (AC: 7)
- [x] Integrate tRPC client for repair operations (AC: 1-8)
  - [x] Use tRPC React hooks for repair creation and history fetching
  - [x] Implement proper loading states during form submission and data fetching
  - [x] Add error handling and user-friendly error messages for all operations
  - [x] Ensure proper error handling for insufficient stock scenarios
  - [x] Add success messaging and navigation after successful repair creation
- [x] Create comprehensive unit tests for repair functionality
  - [x] Test repair creation tRPC procedure with various scenarios
  - [x] Test parts cost calculation from product average costs
  - [x] Test automatic stock deduction logic for multiple parts
  - [x] Test repair cost calculations (total, parts, labor)
  - [x] Test error scenarios (insufficient stock, invalid data, etc.)
  - [x] Test repair history page rendering and navigation
  - [x] Test repair creation form validation and submission
  - [x] Test integration between form, tRPC, and database operations

## Dev Notes

### Previous Story Insights
[Source: Story 4.2 completion notes]
- Sales infrastructure is fully established and working, providing a proven pattern for transaction management
- Product, Customer, and database models are implemented and tested
- tRPC router patterns are established with working authentication and validation
- Stock deduction patterns are proven in sales creation workflow
- UI patterns are consistent with Shadcn/ui components and responsive design
- Testing patterns are established with Jest and React Testing Library for both API and UI components
- All existing functionality (products, customers, sales) can be leveraged for repair job creation

### Data Models and Schema Requirements
[Source: architecture/4-data-models.md#repair + architecture/4-data-models.md#usedpart + architecture/9-database-schema.md]

**Repair Model**: Main repair job record
- `id: String` (unique CUID for identification)
- `customerId: String` (foreign key to Customer for customer selection - AC: 2)
- `description: String` (job title/description field - AC: 3)
- `totalCost: Float` (total repair price charged to customer - AC: 6)
- `partsCost: Float` (total cost of all parts used, calculated from UsedParts)
- `laborCost: Float` (labor cost calculated from `totalCost - partsCost`)
- `createdAt: DateTime` (repair job creation date - AC: 8)
- **Relationships**: One Repair belongs to one Customer, One Repair has many UsedParts

**UsedPart Model**: Individual parts used in repair jobs
- `id: String` (unique CUID)
- `repairId: String` (foreign key to Repair)
- `productId: String` (foreign key to Product for part selection - AC: 4)
- `costAtTime: Float` (cost recorded from product's current `averageCost` - AC: 5)
- **Relationships**: One UsedPart belongs to one Repair, One UsedPart references one Product

**Customer Model**: Existing model for customer selection
- `id: String` (relationship reference)
- `name: String` (customer name display in selection dropdown - AC: 2)

**Product Model**: Existing model for parts selection and stock management
- `id: String` (relationship reference)
- `name: String` (product name display in parts selection - AC: 4)
- `quantity: Int` (stock quantity for deduction - AC: 7)
- `averageCost: Float` (cost source for costAtTime recording - AC: 5)

[Source: architecture/9-database-schema.md#prisma-relationships]
- **Prisma Query Operations**: Use transactions for repair creation with stock deduction
- **Stock Deduction Pattern**: Follow same pattern as sales for atomic operations
- **Cost Calculations**: Parts cost = sum of all UsedPart costAtTime, Labor cost = totalCost - partsCost

### API Specifications
[Source: architecture/5-api-specification.md#repairrouter + existing transaction patterns from sale router]
- **New Router**: Create `src/server/api/routers/repair.ts` following existing patterns
- **Required Procedures**:
  - `create`: Mutation procedure for creating repair jobs with parts and stock deduction (AC: 1-8)
  - `getAll`: Query procedure for fetching repair history list (AC: 1, 8)
- **Input Validation**: Use Zod schema for repair creation:
  ```typescript
  z.object({
    customerId: z.string().cuid("Invalid customer ID"),
    description: z.string().min(1, "Job description is required"),
    totalCost: z.number().positive("Total cost must be positive"),
    usedParts: z.array(z.object({
      productId: z.string().cuid("Invalid product ID"),
      quantity: z.number().int().positive("Quantity must be positive")
    }))
  })
  ```
- **Transaction Logic**: Use Prisma transactions for atomic operations:
  1. Validate sufficient stock for all parts
  2. Create Repair record
  3. Create UsedPart records with costAtTime from product averageCost
  4. Deduct stock quantities from products
  5. Calculate and update parts cost and labor cost
- **Error Handling**: Handle insufficient stock, invalid IDs, and constraint violations
- **Integration**: Add repair router to appRouter in `src/server/api/root.ts`

### Technical Architecture Requirements
[Source: architecture/3-tech-stack-updated-versions-august-2025.md + existing implementation]
- **Backend Framework**: Next.js 15.4.x API Routes with tRPC 11.4.x ✅ ESTABLISHED
- **Database**: PostgreSQL (NeonDB) with Prisma 6.14.x ORM ✅ ESTABLISHED
- **Type Safety**: Full end-to-end type safety with tRPC ✅ ESTABLISHED
- **Frontend Framework**: Next.js 15.4.x with App Router ✅ ESTABLISHED
- **UI Components**: Shadcn/ui Latest with Tailwind CSS 4.1.x ✅ ESTABLISHED
- **Icons**: Lucide Icons 0.539.x ✅ ESTABLISHED
- **Transaction Management**: Proven transaction patterns from sales implementation

### Project Structure Requirements
[Source: architecture/10-unified-project-structure.md + existing codebase verification]
- **Repair Router**: Create new `src/server/api/routers/repair.ts` (new file following existing router patterns)
- **Repairs Page**: Create `src/app/(main)/repairs/page.tsx` (new page following App Router structure)
- **UI Components**: Use existing `src/components/ui/` Shadcn components ✅ AVAILABLE
- **AppRouter Integration**: Extend `src/server/api/root.ts` to include repair router
- **Testing Files**: 
  - Create `src/server/api/routers/repair.test.ts` (new test file following existing patterns)
  - Create `src/app/(main)/repairs/page.test.tsx` (new test file for repairs page)

### Security and Validation Requirements
[Source: architecture/11-implementation-development-standards.md#security + existing patterns]
- **Authentication**: Use existing `protectedProcedure` pattern from tRPC ✅ ESTABLISHED
- **Input Validation**: Strict validation using Zod within tRPC router ✅ PATTERN ESTABLISHED
- **Data Access**: Only allow logged-in users to create and view repairs ✅ PATTERN ESTABLISHED
- **Authorization**: Only logged-in users can access repair functionality ✅ PATTERN ESTABLISHED
- **Stock Validation**: Validate sufficient stock before allowing repair creation
- **Data Integrity**: Use transactions to ensure data consistency during repair creation

### UI/UX Requirements
[Source: Epic 4.3 Acceptance Criteria + existing page patterns]
- **Repairs Page**: New page with repair history table and "Create New Repair Job" button (AC: 1, 8)
- **Repair Creation Form**: Comprehensive form with customer selection, job description, parts selection, and cost input (AC: 2-7)
- **Customer Selection**: Dropdown component for selecting existing customers (AC: 2)
- **Job Description**: Text input field for repair job title/description (AC: 3)
- **Parts Selection**: Search interface for finding and adding products as spare parts (AC: 4)
- **Cost Display**: Show parts costs automatically calculated from average costs (AC: 5)
- **Total Cost Input**: Manual input for total repair price charged to customer (AC: 6)
- **Stock Deduction**: Automatic stock deduction with confirmation on save (AC: 7)
- **Consistent Design**: Follow established Table, Card, Button, Form patterns from existing functionality ✅ ESTABLISHED
- **Error Handling**: User-friendly messages for insufficient stock, validation errors, etc.
- **Loading States**: Clear loading indicators during form submission and data fetching
- **Responsive Design**: Mobile and desktop compatibility following existing patterns

### Component Architecture Requirements
[Source: architecture/6-components.md#transaction-service + existing implementation]
- **Backend Service**: Create Repair Service within Transaction Service group (new service)
- **Frontend Components**: New repair management pages leveraging existing infrastructure
- **Shared UI Components**: Leverage existing Shadcn/ui components (Table, Card, Button, Form, Select) ✅ ESTABLISHED
- **Data Table Pattern**: Follow established patterns from existing sales and customer pages ✅ ESTABLISHED
- **Form Patterns**: Follow established form patterns from customer and product creation

### File Locations and Structure
Based on existing architecture patterns and Next.js App Router:
- **Repair Router**: `src/server/api/routers/repair.ts` (new file)
- **AppRouter Update**: `src/server/api/root.ts` (extend existing file)
- **Repairs Page**: `src/app/(main)/repairs/page.tsx` (new page)
- **UI Components**: Leverage existing `src/components/ui/` Shadcn components ✅ AVAILABLE
- **Test Files**: 
  - `src/server/api/routers/repair.test.ts` (new test file)
  - `src/app/(main)/repairs/page.test.tsx` (new test file)

### Layout System Integration
[Source: existing layout implementation + architecture/12-layout-system.md]
- **MainLayout Integration**: Repairs page integrates with existing main layout ✅ ESTABLISHED
- **Sidebar Navigation**: Add "Repairs" navigation item to existing sidebar (or verify it exists)
- **Responsive Design**: Follow established mobile/desktop responsive patterns ✅ ESTABLISHED
- **Authentication**: Integrate with existing Clerk authentication system ✅ ESTABLISHED

### Technical Constraints
- Repair creation must use Prisma transactions to ensure atomicity of stock deduction and record creation
- Parts cost calculation must use current product average costs to maintain cost accuracy
- Stock deduction must validate sufficient quantities before proceeding with repair creation
- Error handling must gracefully handle insufficient stock scenarios with clear user messaging
- Form validation must prevent submission with missing required fields (customer, description, total cost)
- Currency and date formatting must be consistent with existing sales functionality
- Cost calculations must handle edge cases (zero cost parts, rounding, etc.)

## Testing

### Testing Standards
[Source: architecture/11-implementation-development-standards.md#testing-strategy + existing patterns]
- **Test Location**: Create co-located test files using `*.test.ts` pattern ✅ ESTABLISHED
- **Framework**: Jest v30.0.x and React Testing Library ✅ ESTABLISHED
- **Standards**: Follow Testing Pyramid approach - primarily unit tests ✅ ESTABLISHED
- **Requirements**:
  - Create new repair router tests:
    - Successful repair creation with parts and stock deduction
    - Parts cost calculation from product average costs
    - Automatic stock deduction for multiple parts
    - Repair cost calculations (total, parts, labor)
    - Input validation for all required fields
    - Error handling for insufficient stock scenarios
    - Error handling for invalid customer/product IDs
    - Transaction rollback on failures
  - Create new repairs page component tests:
    - Page rendering with repair history table
    - "Create New Repair Job" button functionality
    - Navigation and routing to repair creation form
    - Loading states during data fetching
    - Error handling for failed data requests
    - Consistent styling with existing page patterns
  - Create repair creation form tests:
    - Customer selection dropdown functionality
    - Job description input validation
    - Parts selection and quantity input
    - Cost calculations and display
    - Total cost input and validation
    - Form submission and success handling
    - Error handling and validation messaging
  - Test repair workflow integration:
    - End-to-end repair creation process
    - Stock deduction verification
    - Data consistency between form inputs and database records
    - Navigation flow from repairs page to creation and back
  - Test business logic validation:
    - Cost calculation accuracy with various repair scenarios
    - Stock quantity validation and deduction logic
    - Data relationship integrity (customer, products, parts)
    - Error boundary behavior for edge cases
- **Commands**: Use existing Jest commands integrated with Next.js ✅ ESTABLISHED

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-08-19 | 1.0 | Initial story creation with comprehensive technical context from architecture documents and previous story insights | Scrum Master |

## Dev Agent Record

### Agent Model Used

claude-sonnet-4-20250514

### Debug Log References

- Database schema updated with `quantity` field for `UsedPart` model
- Migration `20250819112739_add_quantity_to_used_parts` applied successfully
- Fixed linting issue with unused router import in repairs page

### Completion Notes

**Implementation Completed Successfully**: All acceptance criteria (AC: 1-8) have been fully implemented and tested.

**Key Features Delivered:**
1. **Repair Creation**: Complete tRPC router with validation, transaction safety, and error handling
2. **Repairs Page**: Full-featured page with history table, dashboard metrics, and repair creation dialog
3. **Form Components**: Comprehensive repair creation form with customer selection, part management, and cost calculations
4. **Data Models**: Enhanced UsedPart model with quantity field and proper relationships
5. **Testing**: Complete unit test coverage for router logic and page functionality
6. **Code Quality**: All lint checks pass, build compiles successfully

**Technical Highlights:**
- Atomic transactions ensure data consistency between repair creation and stock deduction
- Automatic cost calculations (parts cost from average cost, labor cost from total - parts)
- Real-time form validation and user-friendly error messaging
- Responsive design consistent with existing application patterns
- Comprehensive error handling for edge cases (insufficient stock, invalid data)
- Business intelligence dashboard showing repair metrics and revenue tracking

**Files Created/Modified:**
- Database schema enhanced with quantity field
- New repair router with create and getAll procedures
- Complete repairs page with history and creation functionality
- Comprehensive test suites for router and page logic
- Integration with existing tRPC client architecture

All acceptance criteria successfully implemented with robust error handling, transaction safety, and user experience optimizations.

### File List

**New Files Created:**
- `src/server/api/routers/repair.ts` - Repair tRPC router with create and getAll procedures
- `src/app/(main)/repairs/page.tsx` - Repairs page with history table and creation form
- `src/server/api/routers/repair.test.ts` - Comprehensive router unit tests
- `src/app/(main)/repairs/page.test.tsx` - Page component unit tests
- `prisma/migrations/20250819112739_add_quantity_to_used_parts/migration.sql` - Database migration

**Modified Files:**
- `prisma/schema.prisma` - Added quantity field to UsedPart model
- `src/server/api/root.ts` - Added repair router to appRouter

## QA Results

*To be filled by QA Agent*