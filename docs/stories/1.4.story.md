# Story 1.4: Integrate New Data with Enhanced UI

## Status
Draft

## Story
**As a** developer,
**I want** to connect the data from the enhanced tRPC endpoint to the newly refactored UI components,
**so that** the report page is fully functional and displays complete, accurate information.

## Acceptance Criteria
1. The `reports/summary/page.tsx` correctly calls the enhanced `getMonthlySummary` endpoint.
2. The new `saleItems` and `usedParts` data is passed to and rendered correctly in the respective tables.
3. The new `purchaseRecordsData` is displayed in its dedicated table.
4. The redesigned "Overview" UI correctly displays the key metrics from the API.

## Tasks / Subtasks
- [ ] Task 1: Verify tRPC endpoint integration in summary page (AC: 1)
  - [ ] Confirm summary page calls `api.reports.getMonthlySummary.useQuery` correctly
  - [ ] Verify query parameters (startDate, endDate) are passed properly
  - [ ] Ensure error handling and loading states work with enhanced data structure
- [ ] Task 2: Test data flow from API to ReportView component (AC: 2, 3, 4)
  - [ ] Verify enhanced sales data with saleItems passes correctly to SalesTable
  - [ ] Verify enhanced repairs data with usedParts passes correctly to RepairsTable  
  - [ ] Verify purchaseRecordsData passes correctly to PurchasesTable component
  - [ ] Test overview metrics data flows correctly to OverviewMetrics component
- [ ] Task 3: Handle data structure compatibility issues (AC: 2, 3)
  - [ ] Resolve API vs component naming differences (purchaseRecordsData vs purchaseData)
  - [ ] Ensure proper handling of optional/missing data arrays
  - [ ] Verify type safety between API response and component interfaces
- [ ] Task 4: End-to-end integration testing (AC: 1, 2, 3, 4)
  - [ ] Test complete data flow from API call to UI rendering
  - [ ] Verify all tables display enhanced data correctly (sale items, used parts, purchases)
  - [ ] Test responsive design with enhanced data structures
  - [ ] Ensure backward compatibility if some enhanced data fields are missing
- [ ] Task 5: Write integration tests for complete workflow (AC: 1, 2, 3, 4)
  - [ ] Create integration test for summary page with enhanced API response
  - [ ] Mock enhanced API response with all new data fields
  - [ ] Verify proper rendering of all components with enhanced data
  - [ ] Test error scenarios and edge cases with missing data

## Dev Notes

### Previous Story Insights
**Story 1.1** successfully enhanced the tRPC endpoint to include:
- `saleItems: { name: string }[]` in salesData
- `usedParts: { name: string, costAtTime: number }[]` in repairsData
- New `purchaseRecordsData` array in API response
- All changes maintain backward compatibility

**Story 1.2** successfully refactored ReportView into sub-components:
- Created ReportHeader, OverviewMetrics, SalesTable, RepairsTable, PurchasesTable
- Enhanced TypeScript interfaces with new data structures
- Implemented table total calculations for all monetary columns
- All components handle enhanced data structures properly

**Story 1.3** successfully redesigned Overview UI:
- Updated OverviewMetrics to clean two-column list format
- Added ReportHeader with document-style design
- Maintained responsive design and clean aesthetics
- All visual redesign completed and tested

### Data Models
**Enhanced API Response Structure** [Source: Story 1.1 completion]:
```typescript
interface SalesData {
  date: string;
  totalCost: number;
  netTotal: number;
  totalAmount: number;
  grossProfit: number;
  saleItems: { name: string }[];
}

interface RepairsData {
  date: string;
  description: string;
  partsCost: number;
  laborCost: number;
  totalCost: number;
  usedParts: { name: string; costAtTime: number }[];
}

interface PurchaseRecordDetail {
  id: string;
  quantity: number;
  costPerUnit: number;
  purchaseDate: string | Date;
  product: { name: string };
}

interface SummaryData {
  reportPeriod: ReportPeriod;
  shopInfo: ShopInformation;
  overview: OverviewMetrics;
  salesData: SalesData[];
  repairsData: RepairsData[];
  purchaseRecordsData: PurchaseRecordDetail[]; // API response field name
}
```

### Component Specifications
**Current Component Structure** [Source: Story 1.2 completion]:

**ReportView.tsx** (main orchestrator):
- Handles API response structure differences
- Maps `purchaseRecordsData` to `purchaseData` for component compatibility
- Orchestrates all sub-components with proper data flow
- Location: `src/components/reports/ReportView.tsx`

**Component Data Flow**:
1. **ReportHeader**: Receives `shopInfo` and `reportPeriod` from API
2. **OverviewMetrics**: Receives `overview` metrics from API  
3. **SalesTable**: Receives enhanced `salesData` with `saleItems`
4. **RepairsTable**: Receives enhanced `repairsData` with `usedParts`
5. **PurchasesTable**: Receives `purchaseRecordsData` (mapped to `purchaseData`)

### API Integration Details
**tRPC Query Structure** [Source: docs/architecture/api-design-and-integration-trpc.md]:
- Endpoint: `api.reports.getMonthlySummary.useQuery`
- Input: `{ startDate: string, endDate: string }`
- Location: `src/app/(main)/reports/summary/page.tsx:15`
- Query enabled only when both dates present: `enabled: !!(startDate && endDate)`

**Data Structure Handling** [Source: src/components/reports/ReportView.tsx:112]:
```typescript
// API returns 'purchaseRecordsData' but component expects 'purchaseData'
const purchaseData: PurchaseRecordDetail[] = data.purchaseRecordsData || data.purchaseData || [];
```

### File Locations
**Target Integration Points**:
- Main page: `src/app/(main)/reports/summary/page.tsx` (already correctly structured)
- Main component: `src/components/reports/ReportView.tsx` (data mapping logic exists)
- Component types: `src/components/reports/types.ts` (interfaces aligned)
- Sub-components: All exist in `src/components/reports/` directory

**Project Structure Notes**: All components already follow the established pattern with proper separation of concerns.

### Technical Constraints
**Backward Compatibility** [Source: docs/architecture/enhancement-scope-and-integration-strategy.md]:
- API changes are additive only, not breaking existing fields
- Components handle optional enhanced data gracefully
- ReportView includes fallback logic for missing data arrays

**TypeScript Requirements**:
- Strict typing maintained throughout data flow
- Interface compatibility verified between API response and component props
- Optional field handling for enhanced data arrays

### Testing Standards
**Integration Testing Requirements** [Source: docs/architecture/testing-strategy.md#frontend-testing]:
- **Page Integration Tests**: Update test for `summary/page.tsx` to mock enhanced API response
- **Component Integration**: Verify ReportView properly orchestrates sub-components with enhanced data
- **Data Flow Testing**: Confirm all enhanced data fields reach correct components
- **Regression Testing**: Ensure existing functionality remains intact
- **Responsive Testing**: Verify enhanced data displays correctly across screen sizes

**Test File Locations**: 
- Main page tests: Create `src/app/(main)/reports/summary/page.test.tsx`
- Component integration: Update `src/components/reports/ReportView.test.tsx`
- Mock data should include all enhanced fields: `saleItems`, `usedParts`, `purchaseRecordsData`

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-08-30 | 1.0 | Initial story creation | Scrum Master Bob |

## Dev Agent Record
*This section will be populated by the development agent during implementation*

### Agent Model Used

### Debug Log References

### Completion Notes List

### File List

## QA Results
*This section will be populated by QA Agent after story completion*