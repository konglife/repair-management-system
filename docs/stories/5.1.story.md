# Story 5.1: Create Dashboard Data API

## Status
Draft

## Story
**As a** Developer,
**I want** a single, efficient API endpoint that provides all the summary data required for the Dashboard,
**so that** the front-end can load all its data with one request.

## Acceptance Criteria
1. A new API endpoint is created (e.g., `GET /api/dashboard-summary`).
2. The endpoint can accept a time range parameter (e.g., "today", "last7days", "thismonth").
3. The endpoint returns a JSON object with complete summary data:
   * Total expenses from purchases
   * Total income from repairs
   * Total income from sales
   * Gross profit from sales
   * Gross profit from repairs (labor cost)
4. The endpoint returns data for the trend graph (e.g., total daily income/expenses over the last 30 days).
5. This endpoint must be protected and can only be called by a logged-in user.

## Tasks / Subtasks
- [ ] Create dashboard tRPC router and procedures (AC: 1, 2, 5)
  - [ ] Create new `src/server/api/routers/dashboard.ts` file
  - [ ] Add `getSummary` procedure with time range input validation using Zod
  - [ ] Add `getTrendData` procedure for 30-day trend graph data (AC: 4)
  - [ ] Use `protectedProcedure` pattern for authentication (AC: 5)
  - [ ] Integrate dashboard router into main `appRouter`
- [ ] Implement summary data calculations (AC: 3)
  - [ ] Calculate total expenses from PurchaseRecord model within time range
  - [ ] Calculate total income from Sales model within time range  
  - [ ] Calculate total income from Repairs model within time range
  - [ ] Calculate gross profit from Sales (totalAmount - totalCost) within time range
  - [ ] Calculate gross profit from Repairs (laborCost) within time range
  - [ ] Return structured summary data object matching Epic requirements
- [ ] Implement trend graph data calculations (AC: 4)
  - [ ] Query daily aggregated income (sales + repairs) for last 30 days
  - [ ] Query daily aggregated expenses (purchases) for last 30 days
  - [ ] Return time series data with proper date formatting
  - [ ] Handle edge cases for days with no transactions
- [ ] Add comprehensive unit tests for dashboard functionality
  - [ ] Test getSummary procedure with different time ranges
  - [ ] Test summary calculations accuracy with mock data
  - [ ] Test getTrendData procedure for 30-day period
  - [ ] Test authentication requirements for dashboard endpoints
  - [ ] Test edge cases (empty data, invalid time ranges)
  - [ ] Test database query performance with larger datasets

## Dev Notes

### Previous Story Insights
[Source: Story 4.4 completion notes]
- tRPC router infrastructure is fully established and working, providing proven patterns for API development
- All core data models (Sale, SaleItem, Repair, UsedPart, PurchaseRecord) are implemented and tested
- Authentication patterns with `protectedProcedure` are established and working
- Database relationships and querying patterns are established with Prisma
- Testing patterns are established with Jest for both business logic and API procedures
- Date and cost formatting standards are established across the application

### Data Models and Schema Requirements
[Source: architecture/4-data-models.md + architecture/9-database-schema.md]

**Dashboard Data Sources for Summary Calculations (AC: 3)**:

**PurchaseRecord Model**: Source for total expenses calculation
- `costPerUnit: Float` (cost per unit for purchase)
- `quantity: Int` (quantity purchased)
- `purchaseDate: DateTime` (for time range filtering)
- **Calculation**: `SUM(costPerUnit * quantity)` within time range

**Sale Model**: Source for sales income and profit calculation
- `totalAmount: Float` (gross sales income)
- `totalCost: Float` (cost of goods sold)
- `createdAt: DateTime` (for time range filtering)
- **Income Calculation**: `SUM(totalAmount)` within time range
- **Profit Calculation**: `SUM(totalAmount - totalCost)` within time range

**Repair Model**: Source for repair income and labor profit calculation  
- `totalCost: Float` (total repair income charged to customer)
- `laborCost: Float` (labor profit from repairs)
- `createdAt: DateTime` (for time range filtering)
- **Income Calculation**: `SUM(totalCost)` within time range
- **Profit Calculation**: `SUM(laborCost)` within time range

**Time Range Filtering Requirements**:
- "today": Filter by current date (createdAt/purchaseDate >= start of today)
- "last7days": Filter by last 7 days (createdAt/purchaseDate >= 7 days ago)
- "thismonth": Filter by current month (createdAt/purchaseDate >= start of current month)

### API Specifications
[Source: architecture/5-api-specification.md#dashboard-router + existing patterns]

**Dashboard Router Location**: Create `src/server/api/routers/dashboard.ts`

**Required Procedures**:

1. **getSummary Procedure** (AC: 1, 2, 3, 5):
   ```typescript
   getSummary: protectedProcedure
     .input(z.object({
       period: z.enum(['today', 'last7days', 'thismonth'])
     }))
     .query(async ({ input, ctx }) => {
       // Time range calculation logic
       // Database aggregation queries
       // Return summary object
     })
   ```

2. **getTrendData Procedure** (AC: 4, 5):
   ```typescript
   getTrendData: protectedProcedure
     .query(async ({ ctx }) => {
       // Query last 30 days of daily aggregated data
       // Return time series for income vs expenses
     })
   ```

**Response Data Structure for getSummary** (AC: 3):
```typescript
{
  totalExpenses: number,      // From PurchaseRecord
  totalRepairIncome: number,  // From Repair.totalCost
  totalSalesIncome: number,   // From Sale.totalAmount  
  salesProfit: number,        // From Sale: totalAmount - totalCost
  repairProfit: number        // From Repair.laborCost
}
```

**Response Data Structure for getTrendData** (AC: 4):
```typescript
{
  dailyData: Array<{
    date: string,           // YYYY-MM-DD format
    totalIncome: number,    // Sales + Repairs income for that day
    totalExpenses: number   // Purchases cost for that day
  }>
}
```

**Integration with AppRouter**: Add to `src/server/api/root.ts`:
```typescript
dashboard: dashboardRouter,
```

### Technical Architecture Requirements
[Source: architecture/3-tech-stack-updated-versions-august-2025.md + existing implementation]
- **Backend Framework**: Next.js 15.4.x API Routes with tRPC 11.4.x ✅ ESTABLISHED
- **Database**: PostgreSQL (NeonDB) with Prisma 6.14.x ORM ✅ ESTABLISHED  
- **Type Safety**: Full end-to-end type safety with tRPC ✅ ESTABLISHED
- **Authentication**: Clerk integration with `protectedProcedure` pattern ✅ ESTABLISHED
- **Input Validation**: Zod schema validation within tRPC routers ✅ ESTABLISHED
- **Date Handling**: Use JavaScript Date objects and Prisma DateTime filtering
- **Aggregation**: Use Prisma's aggregation functions for efficient database queries

### Project Structure Requirements
[Source: architecture/10-unified-project-structure.md + existing codebase patterns]
- **Dashboard Router**: Create new `src/server/api/routers/dashboard.ts` (new file)
- **Root Router Integration**: Update existing `src/server/api/root.ts` (extend existing)
- **Testing**: Create `src/server/api/routers/dashboard.test.ts` (new test file)
- **tRPC Client**: Leverage existing tRPC setup in `src/lib/api.ts` ✅ ESTABLISHED

### Security and Validation Requirements
[Source: architecture/11-implementation-development-standards.md#security + existing patterns]
- **Authentication**: Use existing `protectedProcedure` pattern from tRPC ✅ ESTABLISHED
- **Input Validation**: Strict validation using Zod within tRPC procedures ✅ PATTERN ESTABLISHED  
- **Data Access**: Only allow logged-in users to access dashboard data ✅ PATTERN ESTABLISHED
- **Time Range Validation**: Validate time range enum to prevent invalid periods
- **SQL Injection Prevention**: Use Prisma ORM for safe database queries ✅ ESTABLISHED

### Database Query Patterns
[Source: architecture/9-database-schema.md + Prisma documentation]

**Time Range Date Filtering**:
```typescript
// Example for "last7days"
const startDate = new Date();
startDate.setDate(startDate.getDate() - 7);

// Prisma where clause
where: {
  createdAt: {
    gte: startDate
  }
}
```

**Aggregation Queries**:
```typescript
// Sum expenses from purchases
const totalExpenses = await ctx.db.purchaseRecord.aggregate({
  where: { purchaseDate: { gte: startDate } },
  _sum: {
    costPerUnit: true,
    quantity: true
  }
});

// Sum sales income
const salesData = await ctx.db.sale.aggregate({
  where: { createdAt: { gte: startDate } },
  _sum: {
    totalAmount: true,
    totalCost: true
  }
});
```

**Daily Trend Data Query Pattern**:
```typescript
// Group by date for trend data
const trendData = await ctx.db.sale.groupBy({
  by: ['createdAt'],
  where: {
    createdAt: { gte: thirtyDaysAgo }
  },
  _sum: {
    totalAmount: true
  }
});
```

### File Locations and Structure
Based on existing architecture patterns:
- **Dashboard Router**: `src/server/api/routers/dashboard.ts` (new file)
- **Root Router Update**: `src/server/api/root.ts` (modify existing)  
- **Test File**: `src/server/api/routers/dashboard.test.ts` (new test file)
- **Type Exports**: Leverage existing tRPC type system ✅ ESTABLISHED

### Technical Constraints
- Dashboard data queries must be optimized for performance with proper database indexes
- Time range calculations must handle timezone considerations appropriately
- Aggregation queries should use Prisma's built-in aggregation functions for efficiency  
- Trend data must handle days with zero transactions gracefully
- All monetary calculations must maintain precision for financial accuracy
- Response data must be properly typed through tRPC for frontend type safety
- Authentication must be enforced on all dashboard endpoints without exception

## Testing

### Testing Standards
[Source: architecture/11-implementation-development-standards.md#testing-strategy + existing patterns]
- **Test Location**: Create `src/server/api/routers/dashboard.test.ts` using established patterns ✅ ESTABLISHED
- **Framework**: Jest v30.0.x following established testing patterns ✅ ESTABLISHED  
- **Standards**: Follow Testing Pyramid approach - primarily unit tests ✅ ESTABLISHED

**Required Test Coverage**:
- **Dashboard Router Tests**:
  - getSummary procedure with valid time range parameters (today, last7days, thismonth)
  - getSummary procedure with invalid time range parameters (error handling)
  - getTrendData procedure for 30-day period data retrieval
  - Authentication enforcement for both procedures (protectedProcedure testing)
  - Database query execution and proper aggregation calculations
  - Response data structure validation for both procedures

- **Business Logic Calculation Tests**:
  - Total expenses calculation accuracy from PurchaseRecord data
  - Total sales income calculation accuracy from Sale data  
  - Total repair income calculation accuracy from Repair data
  - Sales profit calculation (totalAmount - totalCost) accuracy
  - Repair profit calculation (laborCost) accuracy
  - Time range filtering logic for different periods
  - Daily trend data aggregation and formatting

- **Edge Case Tests**:
  - Empty database scenarios (no transactions in time range)
  - Single day with multiple transactions
  - Time range edge cases (start/end of month boundaries)
  - Large dataset performance (simulated with reasonable test data)
  - Date timezone handling consistency
  - Precision handling for monetary calculations

- **Integration Tests**:
  - Dashboard router integration with main appRouter
  - tRPC type safety verification for dashboard procedures
  - Database connection and transaction handling
  - Authentication integration with Clerk protectedProcedure pattern

**Commands**: Use existing Jest commands integrated with Next.js ✅ ESTABLISHED

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-08-19 | 1.0 | Initial story creation with comprehensive technical context from architecture documents and Epic 5.1 requirements | Scrum Master |

## Dev Agent Record

### Agent Model Used

*To be filled by Dev Agent*

### Debug Log References

*To be filled by Dev Agent*

### Completion Notes

*To be filled by Dev Agent*

### File List

*To be filled by Dev Agent*

## QA Results

*To be filled by QA Agent*